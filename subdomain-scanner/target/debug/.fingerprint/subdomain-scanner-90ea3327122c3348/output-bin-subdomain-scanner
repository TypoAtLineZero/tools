{"$message_type":"diagnostic","message":"closure may outlive the current function, but it borrows `my_vec`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<dyn Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<dyn Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n\nThis error may also be encountered while using `async` blocks:\n\n```compile_fail,E0373,edition2018\nuse std::future::Future;\n\nasync fn f() {\n    let v = vec![1, 2, 3i32];\n    spawn(async { //~ ERROR E0373\n        println!(\"{:?}\", v)\n    });\n}\n\nfn spawn<F: Future + Send + 'static>(future: F) {\n    unimplemented!()\n}\n```\n\nSimilarly to closures, `async` blocks are not executed immediately and may\ncapture closed-over data by reference. For more information, see\n<https://rust-lang.github.io/async-book/03_async_await/01_chapter.html>.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":122,"byte_end":128,"line_start":7,"line_end":7,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"        add_to_vec(& mut my_vec);","highlight_start":26,"highlight_end":32}],"label":"`my_vec` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":92,"byte_end":94,"line_start":6,"line_end":6,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"    thread::spawn(|| {","highlight_start":19,"highlight_end":21}],"label":"may outlive borrowed value `my_vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":78,"byte_end":137,"line_start":6,"line_end":8,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    thread::spawn(|| {","highlight_start":5,"highlight_end":23},{"text":"        add_to_vec(& mut my_vec);","highlight_start":1,"highlight_end":34},{"text":"    });","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `my_vec` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":92,"byte_end":92,"line_start":6,"line_end":6,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"    thread::spawn(|| {","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"move ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0373]\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `my_vec`, which is owned by the current function\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:6:19\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     thread::spawn(|| {\n  \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mmay outlive borrowed value `my_vec`\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         add_to_vec(& mut my_vec);\n  \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94m`my_vec` is borrowed here\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function requires argument type to outlive `'static`\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:6:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m     thread::spawn(|| {\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         add_to_vec(& mut my_vec);\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     });\n  \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|______^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: to force the closure to take ownership of `my_vec` (and any other referenced variables), use the `move` keyword\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    thread::spawn(\u001b[92mmove \u001b[0m|| {\n  \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `my_vec` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":92,"byte_end":94,"line_start":6,"line_end":6,"column_start":19,"column_end":21,"is_primary":false,"text":[{"text":"    thread::spawn(|| {","highlight_start":19,"highlight_end":21}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":144,"byte_end":150,"line_start":10,"line_end":10,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    my_vec.push(34)","highlight_start":5,"highlight_end":11}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":122,"byte_end":128,"line_start":7,"line_end":7,"column_start":26,"column_end":32,"is_primary":false,"text":[{"text":"        add_to_vec(& mut my_vec);","highlight_start":26,"highlight_end":32}],"label":"first borrow occurs due to use of `my_vec` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":78,"byte_end":137,"line_start":6,"line_end":8,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    thread::spawn(|| {","highlight_start":5,"highlight_end":23},{"text":"        add_to_vec(& mut my_vec);","highlight_start":1,"highlight_end":34},{"text":"    });","highlight_start":1,"highlight_end":7}],"label":"argument requires that `my_vec` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"requirement that the value outlives `'static` introduced here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/std/src/thread/mod.rs","byte_start":27294,"byte_end":27301,"line_start":728,"line_end":728,"column_start":15,"column_end":22,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `my_vec` as mutable more than once at a time\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:10:5\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       thread::spawn(|| {\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m-\u001b[0m             \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _____|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         add_to_vec(& mut my_vec);\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mfirst borrow occurs due to use of `my_vec` in closure\u001b[0m\n \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     });\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|______-\u001b[0m \u001b[1m\u001b[94margument requires that `my_vec` is borrowed for `'static`\u001b[0m\n \u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       my_vec.push(34)\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: requirement that the value outlives `'static` introduced here\n  \u001b[1m\u001b[94m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/std/src/thread/mod.rs:728:15\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0373, E0499.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0373, E0499.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0373`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0373`.\u001b[0m\n"}
